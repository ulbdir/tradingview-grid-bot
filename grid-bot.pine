// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© ulbdir

//@version=5
strategy("bot", overlay=true, max_labels_count = 500, max_bars_back=100, process_orders_on_close=true)

var bot_lines= array.new_float()

if barstate.isfirst
    array.clear(bot_lines)
    
    min_price = 30000
    max_price = 70000
    price_inc = 1000
    
    cprice = max_price
    while (cprice > min_price)
        array.push(bot_lines, cprice)
        cprice := cprice - price_inc
    
    array.sort(bot_lines, order.descending)

//order_already_created(price) =>
//    for trade in strategy.opentrades
//        break

// on first candle, draw the grid lines
if barstate.isfirst
    for i = 0 to array.size(bot_lines) - 1 
        line.new(bar_index - 1, array.get(bot_lines, i), bar_index, array.get(bot_lines, i), width=2, color=color.gray, extend=extend.both, style=line.style_dashed)
    
if barstate.isconfirmed
    
    int crossed_line = na
    for i = 0 to array.size(bot_lines) - 1 
        if (high > array.get(bot_lines, i) and low <= array.get(bot_lines, i))
            crossed_line := i
    
    if not na(crossed_line)
        // go back up to 50 candles and see what grid line we did cross last
        for j = 1 to 300
            // if last line crossed was at higher price
            if (crossed_line[j] < crossed_line) or (crossed_line[j] > crossed_line)
                
                float buy_price = na
                if (crossed_line + 1 < array.size(bot_lines))
                    buy_price := array.get(bot_lines, crossed_line+1)
                
                float sell_price = na
                if (crossed_line - 1) >= 0
                    sell_price := array.get(bot_lines, crossed_line - 1)
    
                
                // place limit order to buy
                if not na(buy_price)
                    // cancel any possible buy order at the price
                    strategy.cancel("buy" + str.tostring(buy_price))
                    //strategy.entry("buy@" + str.tostring(buy_price) + "_" + str.tostring(bar_index), strategy.long, limit = buy_price)
                    strategy.order("buy@" + str.tostring(buy_price), strategy.long, limit = buy_price)
    
                if not na(sell_price)
                    // place limit order to sell
                    strategy.cancel("sell@" + str.tostring(sell_price))
                    if (strategy.position_size > 0)
                        strategy.order("sell@" + str.tostring(sell_price), strategy.short, limit = sell_price)
                label.new(bar_index, na, str.tostring(bar_index) + "\nbuy@" + str.tostring(buy_price) + "\nsell@" + str.tostring(sell_price) + "\nsize: " + str.tostring(strategy.position_size), color=color.green, textcolor=color.black, style=label.style_label_down, yloc=yloc.abovebar)
                break
        
            else if na(crossed_line[j])
                // if candle did not cross any line, check next candle
                continue
            else
                // if last candle crossed the same line, ignore this candle and do not generate orders
                //label.new(bar_index, na, str.tostring(crossed_line) + " -> " + str.tostring(crossed_line[j]), color=color.gray, textcolor=color.black, style=label.style_label_down, yloc=yloc.abovebar)
                break

//plot(array.get(bot_lines, crossed_line), linewidth=2, style=plot.style_areabr)
